#!/usr/bin/env perl
# Emacs: -*- mode: cperl; -*-
# For license: see LICENSE file at top-level

use strict;
use warnings;
use diagnostics;

use File::Basename;
my $progname = basename($0);

#
# -- encapsulate debugging output ----------------------------------------
#

my $debug = 0;                  # default

my $debug_env = 'OSHRUN_DEBUG';

if (defined $ENV{$debug_env}) {
  my $d = lc $ENV{$debug_env};
  $debug = ($d =~ /^[y1]/);
}

my $do_effect;

eval 'use Term::ANSIColor';
if ($@) {
  $do_effect = 0;
}
else {
  # only use effects on terminals
  $do_effect = ( -t STDERR );
}

sub debug {
  if ($debug) {
    my $msg = "$progname: @_\n";
    print STDERR $do_effect ? colored($msg, 'bold') : $msg;
  }
}

#
# -- work out which launcher is required ---------------------------------
#

my $launcher = '';

#
# Anything in environment?
#
if (defined $ENV{SHMEM_LAUNCHER}) {
  $launcher = $ENV{SHMEM_LAUNCHER};
}

#
# Configure might have given us a SHMEM_LAUNCHER (otherwise this is a
# strange-looking no-op)
#
if ($launcher eq '') {
  $launcher = '@SHMEM_LAUNCHER@';
}

#
# still nothing, can we find something?
#

eval 'use Memoize';
if(! $@) {
  memoize('which');
}

sub which {
  my $f = shift;
  my @ps = split ':', $ENV{PATH};

  for my $p (@ps) {
    my $try = "$p/$f";
    if ( -x $try ) {
      return $try;
    }
  }
  return undef;
}

#
# Nothing provided, so look for suitable launcher.  Prefer prun from
# PRRTE.
#

if ($launcher eq '') {
  my @Launchers = qw(prun mpiexec mpirun);

  for my $L (@Launchers) {
    my $pl = which($L);
    next unless defined $pl;

    debug("try launcher in \"$pl\"");

    if ($L eq 'prun') {
      my $pr = $pl;
      $pr =~ s%/prun$%/prte%;
      if ( -x $pr ) {
        debug("found daemon in \"$pr\"");
      }
      else {
        debug("prun but no prte, skipping");
        next;
      }
    }

    # take this one
    $launcher = $L;
    last;
  }
}

if ($launcher eq '') {
  die "$progname: unable to find launcher";
}

debug("launcher is \"$launcher\"");

#
# -- do the underlying launch of app -------------------------------------
#

sub bare_launch {
  debug("launch: \"$launcher @ARGV\"");
  return system $launcher, @ARGV;
}

#
# -- for PRRTE, control of prte daemon -----------------------------------
#

#
# Controlling launched daemon
#
my ($prrte_pid, $prrte_pipe);

sub prrte_shutdown {
  #
  # shut down daemons
  #
  kill TERM => $prrte_pid;
  my $killed = waitpid($prrte_pid,0);
  close $prrte_pipe;

  if ($killed == $prrte_pid) {
    debug("PRRTE:$prrte_pid: shut down");
  }
  else {
    die "$progname:$prrte_pid: couldn't kill PRRTE daemon: $!";
  }
}

sub prrte_launch {
  #
  # start daemon in child process
  #
  debug("PRRTE: starting up");

  $prrte_pid = open $prrte_pipe, '-|', 'prte';

  if (! defined $prrte_pid) {
    die "$progname: failed to run PRRTE daemon: $!";
  }

  #
  # parent waits for daemon to be ready, then launches user app
  #
  if ($prrte_pid) {
    my $ready = 0;

    while (<$prrte_pipe>) {
      if (/^DVM ready/) {
        $ready = 1;
        last;
      }
    }

    if (! $ready) {
      prrte_shutdown();

      die "$progname: internal error at line " .
        __LINE__ .
        ", should not be here";
    }

    debug("PRRTE:$prrte_pid: ready");

    #
    # assume worst; if app is good this will later be 0
    #
    my $status = 1;

    if ($ready) {
      $status = bare_launch();
    }

    return $status;
  }
}

#
# -- let's do it! --------------------------------------------------------
#

my $err;

#
# If we're using PRRTE, fire up support, otherwise just launch
#

my $is_prun = basename($launcher) eq 'prun';

if ($is_prun) {
  $err = prrte_launch();

  prrte_shutdown();
}
else {
  $err = bare_launch();
}

exit $err;
